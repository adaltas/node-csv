"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

// Generated by CoffeeScript 2.3.2
// # CSV Stringifier
// Please look at the [project documentation](https://csv.js.org/stringify/) for additional
// information.
var Stringifier, get, stream, underscore, util;
stream = require('stream');
util = require('util');
get = require('lodash.get'); // ## Usage
// This module export a function as its main entry point and return a transform
// stream.
// Refers to the [official prject documentation](http://csv.adaltas.com/stringify/)
// on how to call this function.

module.exports = function () {
  var callback, chunks, data, options, stringifier;

  if (arguments.length === 3) {
    data = arguments[0];
    options = arguments[1];
    callback = arguments[2];
  } else if (arguments.length === 2) {
    if (Array.isArray(arguments[0])) {
      data = arguments[0];
    } else {
      options = arguments[0];
    }

    if (typeof arguments[1] === 'function') {
      callback = arguments[1];
    } else {
      options = arguments[1];
    }
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      callback = arguments[0];
    } else if (Array.isArray(arguments[0])) {
      data = arguments[0];
    } else {
      options = arguments[0];
    }
  }

  if (options == null) {
    options = {};
  }

  stringifier = new Stringifier(options);

  if (data) {
    process.nextTick(function () {
      var d, j, len;

      for (j = 0, len = data.length; j < len; j++) {
        d = data[j];
        stringifier.write(d);
      }

      return stringifier.end();
    });
  }

  if (callback) {
    chunks = [];
    stringifier.on('readable', function () {
      var chunk, results;
      results = [];

      while (chunk = stringifier.read()) {
        results.push(chunks.push(chunk));
      }

      return results;
    });
    stringifier.on('error', function (err) {
      return callback(err);
    });
    stringifier.on('end', function () {
      return callback(null, chunks.join(''));
    });
  }

  return stringifier;
}; // You can also use *util.promisify* native function (Node.js 8+) in order to wrap callbacks into promises for more convenient use when source is a readable stream and you are OK with storing entire result set in memory:
// ```
// const { promisify } = require('util');
// const csv = require('csv');
// const stringifyAsync = promisify(csv.stringify);
// //returns promise
// function generateCsv(sourceData) {
//     return stringifyAsync(sourceData);
// }
// ```
// ## `Stringifier([options])`
// Options are documented [here](http://csv.adaltas.com/stringify/).


Stringifier =
/*#__PURE__*/
function (_stream$Transform) {
  _inherits(Stringifier, _stream$Transform);

  function Stringifier() {
    var _this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Stringifier);

    var base, base1, base2, base3, base4, isRegExp, isString, j, k, len, options, quoted_match, ref, v;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Stringifier).call(this, _objectSpread({}, {
      writableObjectMode: true
    }, options)));
    options = {};

    for (k in opts) {
      v = opts[k]; // Immutable options and camelcase conversion

      options[underscore(k)] = v;
    } //# Default options


    if (options.delimiter == null) {
      options.delimiter = ',';
    }

    if (options.quote == null) {
      options.quote = '"';
    }

    if (options.quoted == null) {
      options.quoted = false;
    }

    if (options.quoted_empty == null) {
      options.quoted_empty = void 0;
    }

    if (options.quoted_string == null) {
      options.quoted_string = false;
    }

    if (options.eof == null) {
      options.eof = true;
    }

    if (options.escape == null) {
      options.escape = '"';
    }

    if (options.header == null) {
      options.header = false;
    } // Normalize the columns option


    options.columns = _this.normalize_columns(options.columns);

    if (options.cast == null) {
      options.cast = {};
    } // Normalize option `quoted_match`


    if (options.quoted_match === void 0 || options.quoted_match === null || options.quoted_match === false) {
      options.quoted_match = null;
    } else if (!Array.isArray(options.quoted_match)) {
      options.quoted_match = [options.quoted_match];
    }

    if (options.quoted_match) {
      ref = options.quoted_match;

      for (j = 0, len = ref.length; j < len; j++) {
        quoted_match = ref[j];
        isString = typeof quoted_match === 'string';
        isRegExp = quoted_match instanceof RegExp;

        if (!isString && !isRegExp) {
          throw Error("Invalid Option: quoted_match must be a string or a regex, got ".concat(JSON.stringify(quoted_match)));
        }
      }
    }

    if (options.cast.bool) {
      // Backward compatibility
      options.cast.boolean = options.cast.bool;
    } // Custom cast


    if ((base = options.cast).string == null) {
      base.string = function (value) {
        return value;
      };
    }

    if ((base1 = options.cast).date == null) {
      base1.date = function (value) {
        // Cast date to timestamp string by default
        return '' + value.getTime();
      };
    }

    if ((base2 = options.cast).boolean == null) {
      base2.boolean = function (value) {
        // Cast boolean to string by default
        if (value) {
          return '1';
        } else {
          return '';
        }
      };
    }

    if ((base3 = options.cast).number == null) {
      base3.number = function (value) {
        // Cast number to string using native casting by default
        return '' + value;
      };
    }

    if ((base4 = options.cast).object == null) {
      base4.object = function (value) {
        // Stringify object as JSON by default
        return JSON.stringify(value);
      };
    }

    if (options.record_delimiter === void 0 || options.record_delimiter === null || options.record_delimiter === false) {
      if (options.record_delimiter == null) {
        options.record_delimiter = '\n';
      }
    } else if (typeof options.record_delimiter === 'string') {
      switch (options.record_delimiter) {
        case 'auto':
          options.record_delimiter = null;
          break;

        case 'unix':
          options.record_delimiter = "\n";
          break;

        case 'mac':
          options.record_delimiter = "\r";
          break;

        case 'windows':
          options.record_delimiter = "\r\n";
          break;

        case 'ascii':
          options.record_delimiter = "\x1E";
          break;

        case 'unicode':
          options.record_delimiter = "\u2028";
      }
    } else if (Buffer.isBuffer(options.record_delimiter)) {
      options.record_delimiter = options.record_delimiter.toString();
    } else {
      throw Error("Invalid Option: record_delimiter must be a string or a buffer, got ".concat(JSON.stringify(options.record_delimiter)));
    } // Internal usage, state related


    if (_this.countWriten == null) {
      _this.countWriten = 0;
    } // Expose options


    _this.options = options;

    _assertThisInitialized(_assertThisInitialized(_this));

    return _this;
  } // ## `Stringifier.prototype._transform(chunk, encoding, callback)`
  // Implementation of the [transform._transform function](https://nodejs.org/api/stream.html#stream_transform_transform_chunk_encoding_callback).


  _createClass(Stringifier, [{
    key: "_transform",
    value: function _transform(chunk, encoding, callback) {
      var base, e, preserve; // Nothing to do if null or undefined

      if (chunk == null) {
        return;
      }

      preserve = _typeof(chunk) !== 'object'; // Emit and stringify the record if an object or an array

      if (!preserve) {
        // Detect columns from the first record
        if (this.countWriten === 0 && !Array.isArray(chunk)) {
          if ((base = this.options).columns == null) {
            base.columns = this.normalize_columns(Object.keys(chunk));
          }
        }

        try {
          this.emit('record', chunk, this.countWriten);
        } catch (error) {
          e = error;
          return this.emit('error', e);
        } // Convert the record into a string


        if (this.options.eof) {
          chunk = this.stringify(chunk);

          if (chunk == null) {
            return;
          }

          chunk = chunk + this.options.record_delimiter;
        } else {
          chunk = this.stringify(chunk);

          if (chunk == null) {
            return;
          }

          if (this.options.header || this.countWriten) {
            chunk = this.options.record_delimiter + chunk;
          }
        }
      }

      if (typeof chunk === 'number') {
        // Emit the csv
        chunk = "".concat(chunk);
      }

      if (this.countWriten === 0) {
        this.headers();
      }

      if (!preserve) {
        this.countWriten++;
      }

      this.push(chunk);
      return callback();
    } // ## `Stringifier.prototype._flush(callback)`
    // Implementation of the [transform._flush function](https://nodejs.org/api/stream.html#stream_transform_flush_callback).

  }, {
    key: "_flush",
    value: function _flush(callback) {
      if (this.countWriten === 0) {
        this.headers();
      }

      return callback();
    } // ## `Stringifier.prototype.stringify(line)`
    // Convert a line to a string. Line may be an object, an array or a string.

  }, {
    key: "stringify",
    value: function stringify(record) {
      var _record, column, columns, containsEscape, containsQuote, containsRowDelimiter, containsdelimiter, delimiter, err, escape, field, i, j, l, newrecord, quote, quoted, quotedMatch, quotedString, ref, ref1, regexp, shouldQuote, type, value;

      if (_typeof(record) !== 'object') {
        return record;
      }

      columns = this.options.columns;
      delimiter = this.options.delimiter;
      quote = this.options.quote;
      escape = this.options.escape;

      if (!Array.isArray(record)) {
        _record = [];

        if (columns) {
          for (i = j = 0, ref = columns.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            value = get(record, columns[i].key);
            _record[i] = typeof value === 'undefined' || value === null ? '' : value;
          }
        } else {
          for (column in record) {
            _record.push(record[column]);
          }
        }

        record = _record;
        _record = null;
      } else if (columns) {
        // Note, we used to have @options.columns
        // We are getting an array but the user want specified output columns. In
        // this case, we respect the columns indexes
        record.splice(columns.length);
      }

      if (Array.isArray(record)) {
        newrecord = '';

        for (i = l = 0, ref1 = record.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
          field = record[i];
          type = _typeof(field);

          try {
            if (type === 'string') {
              // fine 99% of the cases
              field = this.options.cast.string(field);
            } else if (type === 'number') {
              field = this.options.cast.number(field);
            } else if (type === 'boolean') {
              field = this.options.cast.boolean(field);
            } else if (field instanceof Date) {
              field = this.options.cast.date(field);
            } else if (type === 'object' && field !== null) {
              field = this.options.cast.object(field);
            }
          } catch (error) {
            err = error;
            this.emit('error', err);
            return;
          }

          if (field) {
            if (typeof field !== 'string') {
              this.emit('error', Error('Formatter must return a string, null or undefined'));
              return null;
            }

            containsdelimiter = field.indexOf(delimiter) >= 0;
            containsQuote = quote !== '' && field.indexOf(quote) >= 0;
            containsEscape = field.indexOf(escape) >= 0 && escape !== quote;
            containsRowDelimiter = field.indexOf(this.options.record_delimiter) >= 0;
            quoted = this.options.quoted;
            quotedString = this.options.quoted_string && typeof record[i] === 'string';
            quotedMatch = this.options.quoted_match && typeof record[i] === 'string' && this.options.quoted_match.filter(function (quoted_match) {
              if (typeof quoted_match === 'string') {
                return record[i].indexOf(quoted_match) !== -1;
              } else {
                return quoted_match.test(record[i]);
              }
            });
            quotedMatch = quotedMatch && quotedMatch.length > 0;
            shouldQuote = containsQuote || containsdelimiter || containsRowDelimiter || quoted || quotedString || quotedMatch;

            if (shouldQuote && containsEscape) {
              regexp = escape === '\\' ? new RegExp(escape + escape, 'g') : new RegExp(escape, 'g');
              field = field.replace(regexp, escape + escape);
            }

            if (containsQuote) {
              regexp = new RegExp(quote, 'g');
              field = field.replace(regexp, escape + quote);
            }

            if (shouldQuote) {
              field = quote + field + quote;
            }

            newrecord += field;
          } else if (this.options.quoted_empty || this.options.quoted_empty == null && record[i] === '' && this.options.quoted_string) {
            newrecord += quote + quote;
          }

          if (i !== record.length - 1) {
            newrecord += delimiter;
          }
        }

        record = newrecord;
      }

      return record;
    } // ## `Stringifier.prototype.headers`
    // Print the header line if the option "header" is "true".

  }, {
    key: "headers",
    value: function headers() {
      var headers;

      if (!this.options.header) {
        return;
      }

      if (!this.options.columns) {
        return;
      }

      headers = this.options.columns.map(function (column) {
        return column.header;
      });

      if (this.options.eof) {
        headers = this.stringify(headers) + this.options.record_delimiter;
      } else {
        headers = this.stringify(headers);
      }

      return this.push(headers);
    } // ## `Stringifier.prototype.headers`
    // Print the header line if the option "header" is "true".

  }, {
    key: "normalize_columns",
    value: function normalize_columns(columns) {
      var column, k, v;

      if (columns == null) {
        return null;
      }

      if (columns != null) {
        if (_typeof(columns) !== 'object') {
          throw Error('Invalid option "columns": expect an array or an object');
        }

        if (!Array.isArray(columns)) {
          columns = function () {
            var results;
            results = [];

            for (k in columns) {
              v = columns[k];
              results.push({
                key: k,
                header: v
              });
            }

            return results;
          }();
        } else {
          columns = function () {
            var j, len, results;
            results = [];

            for (j = 0, len = columns.length; j < len; j++) {
              column = columns[j];

              if (typeof column === 'string') {
                results.push({
                  key: column,
                  header: column
                });
              } else if (_typeof(column) === 'object' && column != null && !Array.isArray(column)) {
                if (!column.key) {
                  throw Error('Invalid column definition: property "key" is required');
                }

                if (column.header == null) {
                  column.header = column.key;
                }

                results.push(column);
              } else {
                throw Error('Invalid column definition: expect a string or an object');
              }
            }

            return results;
          }();
        }
      }

      return columns;
    }
  }]);

  return Stringifier;
}(stream.Transform);

module.exports.Stringifier = Stringifier;

underscore = function underscore(str) {
  return str.replace(/([A-Z])/g, function (_, match, index) {
    return '_' + match.toLowerCase();
  });
};