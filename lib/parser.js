// Generated by CoffeeScript 1.7.1
var EventEmitter, Parser,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;


/*

Parsing
=======

The library extend the [EventEmitter][event] and emit the following events:

*   *row*   
  Emitted by the parser on each line with the line content as an array of fields.
*   *end*   
  Emitted when no more data will be parsed.
*   *error*   
  Emitted when an error occured.
 */

Parser = (function(_super) {
  __extends(Parser, _super);

  function Parser(csv) {
    this.csv = csv;
    this.options = this.csv.options.from;
    this.lines = 0;
    this.buf = '';
    this.quoting = false;
    this.commenting = false;
    this.field = '';
    this.lastC = '';
    this.nextChar = null;
    this.closingQuote = 0;
    this.line = [];
    this;
  }


  /*
  
  `write(chars)`
  --------------
  
  Parse a string which may hold multiple lines.
  Private state object is enriched on each character until 
  transform is called on a new line.
   */

  Parser.prototype.write = function(chars, end) {
    var areNextCharsRowDelimiters, char, delimLength, escapeIsQuote, i, isDelimiter, isEscape, isQuote, isRowDelimiter, l, ltrim, nextNextCharPas, nextNextCharPos, rowDelimiter, rtrim, _results;
    ltrim = this.options.trim || this.options.ltrim;
    rtrim = this.options.trim || this.options.rtrim;
    chars = this.buf + chars;
    l = chars.length;
    delimLength = this.options.rowDelimiter ? this.options.rowDelimiter.length : 0;
    i = 0;
    if (this.lines === 0 && 0xFEFF === chars.charCodeAt(0)) {
      i++;
    }
    while (i < l) {
      if ((i + delimLength >= l && chars.substr(i, this.options.rowDelimiter.length) !== this.options.rowDelimiter) && !end) {
        break;
      }
      if ((i + this.options.escape.length >= l && chars.substr(i, this.options.escape.length) === this.options.escape) && !end) {
        break;
      }
      char = this.nextChar ? this.nextChar : chars.charAt(i);
      this.lastC = char;
      this.nextChar = chars.charAt(i + 1);
      if (this.options.rowDelimiter == null) {
        if ((this.field === '') && (char === '\n' || char === '\r')) {
          rowDelimiter = char;
          nextNextCharPos = i + 1;
        } else if (this.nextChar === '\n' || this.nextChar === '\r') {
          rowDelimiter = this.nextChar;
          nextNextCharPas = i + 2;
        }
        if (rowDelimiter) {
          this.options.rowDelimiter = rowDelimiter;
          if (rowDelimiter === '\r' && chars.charAt(nextNextCharPas) === '\n') {
            this.options.rowDelimiter += '\n';
          }
          delimLength = this.options.rowDelimiter.length;
        }
      }
      if (char === this.options.escape) {
        escapeIsQuote = this.options.escape === this.options.quote;
        isEscape = this.nextChar === this.options.escape;
        isQuote = this.nextChar === this.options.quote;
        if (!(escapeIsQuote && !this.field && !this.quoting) && (isEscape || isQuote)) {
          i++;
          char = this.nextChar;
          this.nextChar = chars.charAt(i + 1);
          this.field += char;
          i++;
          continue;
        }
      }
      if (char === this.options.quote) {
        if (this.quoting) {
          areNextCharsRowDelimiters = this.options.rowDelimiter && chars.substr(i + 1, this.options.rowDelimiter.length) === this.options.rowDelimiter;
          if (!this.options.relax && this.nextChar && !areNextCharsRowDelimiters && this.nextChar !== this.options.delimiter && this.nextChar !== this.options.comment) {
            return this.error(new Error("Invalid closing quote at line " + (this.lines + 1) + "; found " + (JSON.stringify(this.nextChar)) + " instead of delimiter " + (JSON.stringify(this.options.delimiter))));
          }
          this.quoting = false;
          this.closingQuote = i;
          i++;
          continue;
        } else if (!this.field) {
          this.quoting = true;
          i++;
          continue;
        }
      }
      isDelimiter = char === this.options.delimiter;
      isRowDelimiter = this.options.rowDelimiter && chars.substr(i, this.options.rowDelimiter.length) === this.options.rowDelimiter;
      if (!this.commenting && !this.quoting && char === this.options.comment) {
        this.commenting = true;
      } else if (this.commenting && isRowDelimiter) {
        this.commenting = false;
      }
      if (!this.commenting && !this.quoting && (isDelimiter || isRowDelimiter)) {
        if (isRowDelimiter && this.line.length === 0 && this.field === '') {
          i += this.options.rowDelimiter.length;
          this.nextChar = chars.charAt(i);
          continue;
        }
        if (rtrim) {
          if (this.closingQuote) {
            this.field = this.field.substr(0, this.closingQuote);
          } else {
            this.field = this.field.trimRight();
          }
        }
        this.line.push(this.field);
        this.closingQuote = 0;
        this.field = '';
        if (isRowDelimiter) {
          this.emit('row', this.line);
          this.line = [];
          i += this.options.rowDelimiter.length;
          this.nextChar = chars.charAt(i);
          continue;
        }
      } else if (!this.commenting && !this.quoting && (char === ' ' || char === '\t')) {
        if (!(ltrim && !this.field)) {
          this.field += char;
        }
      } else if (!this.commenting) {
        this.field += char;
      }
      i++;
    }
    this.buf = '';
    _results = [];
    while (i < l) {
      this.buf += chars.charAt(i);
      _results.push(i++);
    }
    return _results;
  };

  Parser.prototype.end = function() {
    this.write('', true);
    if (this.quoting) {
      return this.error(new Error("Quoted field not terminated at line " + (this.lines + 1)));
    }
    if (this.field || this.lastC === this.options.delimiter || this.lastC === this.options.quote) {
      if (this.options.trim || this.options.rtrim) {
        this.field = this.field.trimRight();
      }
      this.line.push(this.field);
      this.field = '';
    }
    if (this.line.length > 0) {
      this.emit('row', this.line);
    }
    return this.emit('end', null);
  };

  Parser.prototype.error = function(e) {
    return this.emit('error', e);
  };

  return Parser;

})(EventEmitter);

module.exports = function(csv) {
  return new Parser(csv);
};

module.exports.Parser = Parser;


/*
[event]: http://nodejs.org/api/events.html
 */
