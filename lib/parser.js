// Generated by CoffeeScript 1.3.3
var EventEmitter, Parser;

EventEmitter = require('events').EventEmitter;

/*

Parsing
=======

The library extend the [EventEmitter][event] and emit the following events:

*   *row*   
  Emitted by the parser on each line with the line content as an array of fields.
*   *end*   
  Emitted when no more data will be parsed.
*   *error*   
  Emitted when an error occured.
*/


Parser = function(csv) {
  this.csv = csv;
  this.options = csv.options.from;
  this.state = csv.state;
  this.quoted = false;
  this.commented = false;
  this.lines = 0;
  return this;
};

Parser.prototype.__proto__ = EventEmitter.prototype;

/*

`parse(chars)`
--------------

Parse a string which may hold multiple lines.
Private state object is enriched on each character until 
transform is called on a new line.
*/


Parser.prototype.parse = function(chars) {
  var c, csv, escapeIsQuote, i, isEscape, isQuote, isReallyEscaped, l, nextChar;
  csv = this.csv;
  chars = '' + chars;
  l = chars.length;
  i = 0;
  if (this.lines === 0 && csv.options.from.encoding === 'utf8' && 0xFEFF === chars.charCodeAt(0)) {
    i++;
  }
  while (i < l) {
    c = chars.charAt(i);
    switch (c) {
      case this.options.escape:
      case this.options.quote:
        if (this.commented) {
          break;
        }
        isReallyEscaped = false;
        if (c === this.options.escape) {
          nextChar = chars.charAt(i + 1);
          escapeIsQuote = this.options.escape === this.options.quote;
          isEscape = nextChar === this.options.escape;
          isQuote = nextChar === this.options.quote;
          if (!(escapeIsQuote && !this.state.field && !this.quoted) && (isEscape || isQuote)) {
            i++;
            isReallyEscaped = true;
            c = chars.charAt(i);
            this.state.field += c;
          }
        }
        if (!isReallyEscaped && c === this.options.quote) {
          if (this.state.field && !this.quoted) {
            this.state.field += c;
            break;
          }
          if (this.quoted) {
            nextChar = chars.charAt(i + 1);
            if (nextChar && nextChar !== '\r' && nextChar !== '\n' && nextChar !== this.options.delimiter) {
              return this.error(new Error("Invalid closing quote at line " + (this.lines + 1) + "; found " + (JSON.stringify(nextChar)) + " instead of delimiter " + (JSON.stringify(this.options.delimiter))));
            }
            this.quoted = false;
          } else if (this.state.field === '') {
            this.quoted = true;
          }
        }
        break;
      case this.options.delimiter:
        if (this.commented) {
          break;
        }
        if (this.quoted) {
          this.state.field += c;
        } else {
          if (this.options.trim || this.options.rtrim) {
            this.state.field = this.state.field.trimRight();
          }
          this.state.line.push(this.state.field);
          this.state.field = '';
        }
        break;
      case '\n':
      case '\r':
        if (this.quoted) {
          this.state.field += c;
          break;
        }
        if (!this.options.quoted && this.state.lastC === '\r') {
          break;
        }
        this.lines++;
        if (csv.options.to.lineBreaks === null) {
          csv.options.to.lineBreaks = c + (c === '\r' && chars.charAt(i + 1) === '\n' ? '\n' : '');
        }
        if (this.options.trim || this.options.rtrim) {
          this.state.field = this.state.field.trimRight();
        }
        this.state.line.push(this.state.field);
        this.state.field = '';
        this.emit('row', this.state.line);
        this.state.line = [];
        break;
      case ' ':
      case '\t':
        if (this.quoted || (!this.options.trim && !this.options.ltrim) || this.state.field) {
          this.state.field += c;
          break;
        }
        break;
      default:
        if (this.commented) {
          break;
        }
        this.state.field += c;
    }
    this.state.lastC = c;
    i++;
  }
};

Parser.prototype.end = function() {
  if (this.quoted) {
    return this.error(new Error("Quoted field not terminated at line " + (this.lines + 1)));
  }
  if (this.state.field || this.state.lastC === this.options.delimiter || this.state.lastC === this.options.quote) {
    if (this.options.trim || this.options.rtrim) {
      this.state.field = this.state.field.trimRight();
    }
    this.state.line.push(this.state.field);
    this.state.field = '';
  }
  if (this.state.line.length > 0) {
    this.emit('row', this.state.line);
  }
  return this.emit('end', null);
};

Parser.prototype.error = function(e) {
  return this.emit('error', e);
};

module.exports = function(csv) {
  return new Parser(csv);
};

module.exports.Parser = Parser;

/*
[event]: http://nodejs.org/api/events.html
*/

