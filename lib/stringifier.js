// Generated by CoffeeScript 1.6.3
/*

Stringifier
===========

Convert an array or an object into a CSV line.
*/

var Stringifier,
  __hasProp = {}.hasOwnProperty;

Stringifier = function(csv) {
  this.csv = csv;
  return this;
};

/*

`write(line, [preserve])`
-------------------------

Write a line to the written stream. Line may be an object, an array or a string
The `preserve` argument is for the lines which are not considered as CSV data.
*/


Stringifier.prototype.write = function(line) {
  var e, preserve;
  if (line == null) {
    return;
  }
  preserve = typeof line !== 'object';
  if (!preserve) {
    try {
      this.csv.emit('record', line, this.csv.state.count - 1);
    } catch (_error) {
      e = _error;
      return this.csv.error(e);
    }
    line = this.csv.stringifier.stringify(line);
  }
  if (typeof line === 'number') {
    line = "" + line;
  }
  this.csv.emit('data', line);
  if (!preserve) {
    this.csv.state.countWriten++;
  }
  return true;
};

/*

`Stringifier(line)`
-------------------

Convert a line to a string. Line may be an object, an array or a string.
*/


Stringifier.prototype.stringify = function(line) {
  var column, columns, containsLinebreak, containsQuote, containsdelimiter, delimiter, escape, field, i, newLine, quote, regexp, _i, _j, _line, _ref, _ref1;
  if (typeof line !== 'object') {
    return line;
  }
  columns = this.csv.options.to.columns || this.csv.options.from.columns;
  if (typeof columns === 'object' && columns !== null && !Array.isArray(columns)) {
    columns = Object.keys(columns);
  }
  delimiter = this.csv.options.to.delimiter || this.csv.options.from.delimiter;
  quote = this.csv.options.to.quote || this.csv.options.from.quote;
  escape = this.csv.options.to.escape || this.csv.options.from.escape;
  if (!Array.isArray(line)) {
    _line = [];
    if (columns) {
      for (i = _i = 0, _ref = columns.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        column = columns[i];
        _line[i] = typeof line[column] === 'undefined' || line[column] === null ? '' : line[column];
      }
    } else {
      for (column in line) {
        if (!__hasProp.call(line, column)) continue;
        _line.push(line[column]);
      }
    }
    line = _line;
    _line = null;
  } else if (columns) {
    line.splice(columns.length);
  }
  if (Array.isArray(line)) {
    newLine = this.csv.state.countWriten ? this.csv.options.to.rowDelimiter || "\n" : '';
    for (i = _j = 0, _ref1 = line.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      field = line[i];
      if (typeof field === 'string') {

      } else if (typeof field === 'number') {
        field = '' + field;
      } else if (typeof field === 'boolean') {
        field = field ? '1' : '';
      } else if (field instanceof Date) {
        field = '' + field.getTime();
      }
      if (field) {
        containsdelimiter = field.indexOf(delimiter) >= 0;
        containsQuote = field.indexOf(quote) >= 0;
        containsLinebreak = field.indexOf("\r") >= 0 || field.indexOf("\n") >= 0;
        if (containsQuote) {
          regexp = new RegExp(quote, 'g');
          field = field.replace(regexp, escape + quote);
        }
        if (containsQuote || containsdelimiter || containsLinebreak || this.csv.options.to.quoted) {
          field = quote + field + quote;
        }
        newLine += field;
      }
      if (i !== line.length - 1) {
        newLine += delimiter;
      }
    }
    line = newLine;
  }
  return line;
};

module.exports = function(csv) {
  return new Stringifier(csv);
};

module.exports.Stringifier = Stringifier;
