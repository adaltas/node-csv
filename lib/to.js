// Generated by CoffeeScript 1.7.1
var Stream, fs, utils;

fs = require('fs');

Stream = require('stream');

utils = require('./utils');


/*

Writing data to a destination
=============================

The `csv().to` property provides functions to read from a CSV instance and
to write to an external destination. The destination may be a stream, a file
or a callback.

You may call the `to` function or one of its sub function. For example,
here are two identical ways to write to a file:

    csv.from(data).to('/tmp/data.csv');
    csv.from(data).to.path('/tmp/data.csv');
 */

module.exports = function(csv) {

  /*
  
  `to(mixed)`
  -----------
  
  Write from any sort of destination. It should be considered as a convenient function
  which will discover the nature of the destination where to write the CSV data.
  
  If the parameter is a function, then the csv will be provided as the first argument
  of the callback. If it is a string, then it is expected to be a
  file path. If it is an instance of `stream`, it consider the object to be an
  output stream.
  
  Here's some examples on how to use this function:
  
      csv()
      .from('"1","2","3","4","5"')
      .to(function(data){ console.log(data) })
  
      csv()
      .from('"1","2","3","4","5"')
      .to('./path/to/file.csv')
  
      csv()
      .from('"1","2","3","4","5"')
      .to(fs.createWriteStream('./path/to/file.csv'))
   */
  var to;
  to = function(mixed, options) {
    var error;
    error = false;
    switch (typeof mixed) {
      case 'string':
        to.path(mixed, options);
        break;
      case 'object':
        if (mixed instanceof Stream) {
          to.stream(mixed, options);
        } else {
          error = true;
        }
        break;
      case 'function':
        to.string(mixed, options);
        break;
      default:
        error = true;
    }
    if (error) {
      csv.error(new Error("Invalid mixed argument in from"));
    }
    return csv;
  };
  to.options = function(options) {
    if (options != null) {
      utils.merge(csv.options.to, options);
      if (csv.options.to.lineBreaks) {
        console.log('To options linebreaks is replaced by rowDelimiter');
        if (!csv.options.to.rowDelimiter) {
          csv.options.to.rowDelimiter = csv.options.to.lineBreaks;
        }
      }
      switch (csv.options.to.rowDelimiter) {
        case 'auto':
          csv.options.to.rowDelimiter = null;
          break;
        case 'unix':
          csv.options.to.rowDelimiter = "\n";
          break;
        case 'mac':
          csv.options.to.rowDelimiter = "\r";
          break;
        case 'windows':
          csv.options.to.rowDelimiter = "\r\n";
          break;
        case 'unicode':
          csv.options.to.rowDelimiter = "\u2028";
      }
      return csv;
    } else {
      return csv.options.to;
    }
  };

  /*
  
  `to.string(callback, [options])`
  ------------------------------
  
  Provide the output string to a callback.
  
      csv()
      .from( '"1","2","3"\n"a","b","c"' )
      .to.string( function(data, count){} )
  
  Callback is called with 2 arguments:
  *   data      Entire CSV as a string
  *   count     Number of stringified records
   */
  to.string = function(callback, options) {
    var data, stream;
    this.options(options);
    data = [];
    stream = new Stream;
    stream.writable = true;
    stream.write = function(d) {
      data.push(d);
      return true;
    };
    stream.end = function() {
      return callback(data.join(''), csv.state.countWriten);
    };
    csv.pipe(stream);
    return csv;
  };

  /*
  
  `to.stream(stream, [options])`
  ------------------------------
  
  Write to a stream. Take a writable stream as first argument and
  optionally an object of options as a second argument.
  
  Additionnal options may be defined. See the [`readable.pipe`
  documentation][srpdo] for additionnal information.
  
  [srpdo]: http://www.nodejs.org/api/stream.html#stream_readable_pipe_destination_options
   */
  to.stream = function(stream, options) {
    this.options(options);
    csv.pipe(stream, csv.options.to);
    stream.on('error', function(e) {
      return csv.error(e);
    });
    stream.on('close', function() {
      return csv.emit('close', csv.state.count);
    });
    stream.on('finish', function() {
      return csv.emit('finish', csv.state.count);
    });
    return csv;
  };

  /*
  
  `to.path(path, [options])`
  --------------------------
  
  Write to a path. Take a file path as first argument and optionally an object of
  options as a second argument. The `close` event is sent after the file is written.
  Relying on the `end` event is incorrect because it is sent when parsing is done
  but before the file is written.
  
  Additionnal options may be defined with the following default:
  
      { flags: 'w',
        encoding: null,
        mode: 0666 }
  
  See the [`fs.createReadStream` documentation][fscpo] for additionnal information.
  
  [fscpo]: http://www.nodejs.org/api/fs.html#fs_fs_createwritestream_path_options
  
  Example to modify a file rather than replacing it:
  
      csv()
      .to.file('my.csv', {flags:'r+'})
      .write(['hello', 'node'])
      .end()
   */
  to.path = function(path, options) {
    var stream;
    this.options(options);
    options = utils.merge({}, csv.options.to);
    delete options.end;
    stream = fs.createWriteStream(path, options);
    csv.to.stream(stream, null);
    return csv;
  };

  /*
  
  `to.array(path, [options])`
  --------------------------
  
  Provide the output string to a callback.
  
      csv()
      .from( '"1","2","3"\n"a","b","c"' )
      .to.array( function(data, count){} )
  
  Callback is called with 2 arguments:
  *   data      Entire CSV as an array of records
  *   count     Number of stringified records
   */
  to.array = function(callback, options) {
    var headerSeen, headers, records;
    this.options(options);
    headers = [];
    headerSeen = false;
    records = [];
    csv.on('record', function(record) {
      var column, i, item, _i, _j, _k, _l, _len, _len1, _len2, _len3, _record, _ref, _ref1;
      if (this.options.to.columns) {
        headerSeen = true;
        if (Array.isArray(record)) {
          _record = record;
          record = {};
          _ref = this.options.to.columns;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            column = _ref[i];
            record[column] = _record[i];
          }
        } else {
          _record = record;
          record = {};
          _ref1 = this.options.to.columns;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            column = _ref1[_j];
            record[column] = _record[column];
          }
        }
      } else if (this.options.to.header) {
        if (!headerSeen) {
          if (record[0] != null) {
            headerSeen = true;
            headers = record;
            return headers;
          }
        } else {
          if (Array.isArray(record)) {
            _record = record;
            record = {};
            for (i = _k = 0, _len2 = _record.length; _k < _len2; i = ++_k) {
              item = _record[i];
              record[headers[i]] = _record[i];
            }
          } else {
            _record = record;
            record = {};
            for (i = _l = 0, _len3 = _record.length; _l < _len3; i = ++_l) {
              item = _record[i];
              record[headers[i]] = _record[i];
            }
          }
        }
      }
      if (this.options.to.header) {
        if (headerSeen === true) {
          return records.push(record);
        }
      } else {
        return records.push(record);
      }
    });
    csv.on('end', function() {
      return callback(records, csv.state.countWriten);
    });
    return csv;
  };

  /*
  
  to.object(path, [options])`
  --------------------------
  
  Provide the output string to a callback.
  
      csv()
      .from( '"Name","Age"\n"a","12"' )
      .to.object(function(data, count){}, )
  
  Callback is called with 2 arguments:
  *   data      Entire CSV as an object of records, addressable by 'objName'
  *   count     Number of stringified records
   */
  to.object = function(callback, options) {
    var headerSeen, headers, records;
    this.options(options);
    headers = [];
    headerSeen = false;
    records = {};
    if (!options.objname) {
      return callback({
        "error": "You need to specify objName: to.object(callback, objName);"
      }, 0);
    }
    csv.on('record', function(record) {
      var column, i, item, _i, _j, _k, _l, _len, _len1, _len2, _len3, _record, _ref, _ref1;
      if (this.options.to.columns) {
        if (!headerSeen) {
          if (record[0] != null) {
            headerSeen = true;
            headers = record;
            return headers;
          }
        } else {
          if (Array.isArray(record)) {
            _record = record;
            record = {};
            _ref = this.options.to.columns;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              column = _ref[i];
              record[column] = _record[i];
            }
          } else {
            _record = record;
            record = {};
            _ref1 = this.options.to.columns;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              column = _ref1[_j];
              record[column] = _record[column];
            }
          }
        }
      } else if (this.options.to.header) {
        if (!headerSeen) {
          if (record[0] != null) {
            headerSeen = true;
            headers = record;
            return headers;
          }
        } else {
          if (Array.isArray(record)) {
            _record = record;
            record = {};
            for (i = _k = 0, _len2 = _record.length; _k < _len2; i = ++_k) {
              item = _record[i];
              record[headers[i]] = _record[i];
            }
          } else {
            _record = record;
            record = {};
            for (i = _l = 0, _len3 = _record.length; _l < _len3; i = ++_l) {
              item = _record[i];
              record[headers[i]] = _record[i];
            }
          }
        }
      }
      if (this.options.to.header) {
        if (headerSeen === true) {
          return records[record[this.options.to.objname].trim()] = record;
        }
      } else {
        return records[record[this.options.to.objname].trim()] = record;
      }
    });
    csv.on('end', function() {
      return callback(records, csv.state.countWriten);
    });
    return csv;
  };
  return to;
};
