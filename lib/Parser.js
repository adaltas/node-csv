// Generated by CoffeeScript 1.3.3
var EventEmitter, Parser, stream;

stream = require('stream');

EventEmitter = require('events').EventEmitter;

/*

Parsing
=======

The library extend the EventEmitter and emit the following events:

*   *row*
    Emitted by the parser on each line with the line content as an array of fields.
*   *end*
*   *error*
*/


Parser = function(csv) {
  this.writable = true;
  this.csv = csv;
  this.options = csv.options.from;
  this.state = csv.state;
  this.quoted = false;
  this.commented = false;
  return this;
};

Parser.prototype.__proto__ = EventEmitter.prototype;

/*

`parse(chars)`
--------------

Parse a string which may hold multiple lines.
Private state object is enriched on each character until 
transform is called on a new line.
*/


Parser.prototype.parse = function(chars) {
  var c, csv, escapeIsQuoted, i, isEscaped, isQuoted, isReallyEscaped, l, nextChar;
  if (!this.writable) {
    return this.error(new Error('Parser is not writable'));
  }
  csv = this.csv;
  chars = '' + chars;
  l = chars.length;
  i = 0;
  while (i < l) {
    c = chars.charAt(i);
    switch (c) {
      case this.options.escape:
      case this.options.quote:
        if (this.commented) {
          break;
        }
        isReallyEscaped = false;
        if (c === this.options.escape) {
          nextChar = chars.charAt(i + 1);
          escapeIsQuoted = this.options.escape === this.options.quote;
          isEscaped = nextChar === this.options.escape;
          isQuoted = nextChar === this.options.quote;
          if (!(escapeIsQuoted && !this.state.field && !this.quoted) && (isEscaped || isQuoted)) {
            i++;
            isReallyEscaped = true;
            c = chars.charAt(i);
            this.state.field += c;
          }
        }
        if (!isReallyEscaped && c === this.options.quote) {
          if (this.state.field && !this.quoted) {
            this.state.field += c;
            break;
          }
          if (this.quoted) {
            nextChar = chars.charAt(i + 1);
            if (nextChar && nextChar !== '\r' && nextChar !== '\n' && nextChar !== this.options.delimiter) {
              return this.error(new Error('Invalid closing quote; found ' + JSON.stringify(nextChar) + ' instead of delimiter ' + JSON.stringify(this.options.delimiter)));
            }
            this.quoted = false;
          } else if (this.state.field === '') {
            this.quoted = true;
          }
        }
        break;
      case this.options.delimiter:
        if (this.commented) {
          break;
        }
        if (this.quoted) {
          this.state.field += c;
        } else {
          if (this.options.trim || this.options.rtrim) {
            this.state.field = this.state.field.trimRight();
          }
          this.state.line.push(this.state.field);
          this.state.field = '';
        }
        break;
      case '\n':
      case '\r':
        if (this.quoted) {
          this.state.field += c;
          break;
        }
        if (!this.options.quoted && this.state.lastC === '\r') {
          break;
        }
        if (csv.options.to.lineBreaks === null) {
          csv.options.to.lineBreaks = c + (c === '\r' && chars.charAt(i + 1) === '\n' ? '\n' : '');
        }
        if (this.options.trim || this.options.rtrim) {
          this.state.field = this.state.field.trimRight();
        }
        this.state.line.push(this.state.field);
        this.state.field = '';
        this.emit('row', this.state.line);
        this.state.line = [];
        break;
      case ' ':
      case '\t':
        if (this.quoted || (!this.options.trim && !this.options.ltrim) || this.state.field) {
          this.state.field += c;
          break;
        }
        break;
      default:
        if (this.commented) {
          break;
        }
        this.state.field += c;
    }
    this.state.lastC = c;
    i++;
  }
};

Parser.prototype.end = function() {
  if (this.quoted) {
    return this.error(new Error('Quoted field not terminated'));
  }
  if (this.state.field || this.state.lastC === this.options.delimiter || this.state.lastC === this.options.quote) {
    if (this.options.trim || this.options.rtrim) {
      this.state.field = this.state.field.trimRight();
    }
    this.state.line.push(this.state.field);
    this.state.field = '';
  }
  if (this.state.line.length > 0) {
    this.emit('row', this.state.line);
  }
  return this.emit('end', null);
};

Parser.prototype.error = function(e) {
  this.writable = false;
  return this.emit('error', e);
};

module.exports = function(csv) {
  return new Parser(csv);
};

module.exports.Parser = Parser;
