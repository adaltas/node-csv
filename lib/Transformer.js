// Generated by CoffeeScript 1.3.3
/*
Transforming data
=================

The contract is quite simple, you receive an array of fields for 
each record and return the transformed record. The return value 
may be an array, an associative array, a string or null. If null, 
the record will simply be skipped.

Unless you specify the `columns` read option, `data` are provided 
as arrays, otherwise they are objects with keys matching columns 
names.

When the returned value is an array, the fields are merged in 
order. When the returned value is an object, it will search for 
the `columns` property in the write or in the read options and 
smartly order the values. If no `columns` options are found, 
it will merge the values in their order of appearance. When the 
returned value is a string, it is directly sent to the destination 
source and it is your responsibility to delimit, quote, escape 
or define line breaks.

Example of transform returning a string:

    csv()
    .from('82,Preisner,Zbigniew\n94,Gainsbourg,Serge')
    .to(console.log)
    .transform(function(data,index){
        return (index>0 ? ',' : '') + data[0] + ":" + data[2] + ' ' + data[1];
    });

    // Executing `node samples/transform.js`, print:
    // 82:Zbigniew Preisner,94:Serge Gainsbourg
*/

var Transformer;

Transformer = function(csv) {
  this.csv = csv;
  return this;
};

/*

`transformer(csv).transform(line)`
-----------------

Internal function. Call a callback to transform a line. Called from the `parse` function on each 
line. It is responsible for transforming the data and finally calling `write`.
*/


Transformer.prototype.transform = function(line) {
  var column, columns, i, isObject, lineAsObject, _i, _len;
  columns = this.csv.options.from.columns;
  if (columns) {
    if (this.csv.state.count === 0 && columns === true) {
      this.csv.options.from.columns = columns = line;
      return;
    }
    lineAsObject = {};
    for (i = _i = 0, _len = columns.length; _i < _len; i = ++_i) {
      column = columns[i];
      lineAsObject[column] = line[i] || null;
    }
    line = lineAsObject;
  }
  if (this.callback) {
    this.csv.state.transforming = true;
    try {
      line = this.callback(line, this.csv.state.count);
    } catch (e) {
      return this.csv.error(e);
    }
    isObject = typeof line === 'object' && !Array.isArray(line);
    if (this.csv.options.to.newColumns && !this.csv.options.to.columns && isObject) {
      Object.keys(line).filter(function(column) {
        return columns.indexOf(column) === -1;
      }).forEach(function(column) {
        return columns.push(column);
      });
    }
    this.csv.state.transforming = false;
  }
  if (this.csv.state.count === 0 && this.csv.options.to.header === true) {
    this.csv.stringifier.write(this.csv.options.to.columns || columns);
  }
  this.csv.stringifier.write(line);
  return this.csv.state.count++;
};

module.exports = function(csv) {
  return new Transformer(csv);
};

module.exports.Transformer = Transformer;
